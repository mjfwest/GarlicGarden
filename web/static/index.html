<!DOCTYPE html>
<div id="container"></div>
<div class="controls">
  <div>
    <p>Data Streams:</p>
    <div id="stream-checkboxes" class="checkbox-group"></div>
  </div>
  <div>
    <label for="window-select">Display Window:</label>
    <select id="window-select">
      <option value="60">1 minute</option>
      <option value="600">10 minutes</option>
      <option value="3600">1 hour</option>
    </select>
  </div>
</div>
<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
import { io } from "https://cdn.socket.io/4.4.1/socket.io.esm.min.js";

const width = 640, height = 400, marginTop = 20, marginRight = 20, marginBottom = 30, marginLeft = 40;
const x = d3.scaleUtc().range([marginLeft, width - marginRight]);
const y = d3.scaleLinear().domain([0, 4096]).range([height - marginBottom, marginTop]);
const svg = d3.create("svg").attr("width", width).attr("height", height);
const xAxisGroup = svg.append("g").attr("class", "x-axis").attr("transform", `translate(0,${height - marginBottom})`);
const yAxisGroup = svg.append("g").attr("class", "y-axis").attr("transform", `translate(${marginLeft},0)`);
container.append(svg.node());

// Add a legend group
const legend = svg.append("g")
  .attr("class", "legend")
  .attr("transform", `translate(${width - 120}, ${marginTop + 10})`);


const socket = io({ transports: ['websocket'], upgrade: false });
const streamColors = { humidity: "#1f77b4", temperature: "#ff8c00" };
const streamNames = {}; // Add this to store friendly names
let subscribedStreams = new Set();
let streamData = {};
let displayWindow = 60; // default to 1 minute


// Fetch available streams and populate checkboxes
fetch('/streams')
  .then(response => response.json())
  .then(streams => {
    const checkboxContainer = document.getElementById('stream-checkboxes');
    
    // Save colors and names for later use
    streams.forEach(stream => {
      streamColors[stream.id] = stream.colour;
      streamNames[stream.id] = stream.name; // Save the friendly name
    });
    
    // Create a checkbox for each stream
    streams.forEach(stream => {
      const checkbox = document.createElement('div');
      checkbox.className = 'checkbox-item';
      
      // Create colour swatch
      const swatch = document.createElement('span');
      swatch.className = 'colour-swatch';
      swatch.style.backgroundColor = stream.colour;
      checkbox.appendChild(swatch);
      
      // Create actual checkbox input
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.id = `stream-${stream.id}`;
      input.value = stream.id;
      input.checked = true; // Default to checked
      checkbox.appendChild(input);
      
      // Create label
      const label = document.createElement('label');
      label.htmlFor = `stream-${stream.id}`;
      label.textContent = stream.name;
      checkbox.appendChild(label);
      
      checkboxContainer.appendChild(checkbox);
      
      // Subscribe to this stream initially
      subscribedStreams.add(stream.id);
      subscribeToStream(stream.id);
      
      // Add change event listener
      input.addEventListener('change', function() {
        if (this.checked) {
          subscribeToStream(this.value);
          subscribedStreams.add(this.value);
        } else {
          socket.emit("unsubscribe", { stream: this.value });
          subscribedStreams.delete(this.value);
          delete streamData[this.value];
          updateChart();
          updateLegend();
        }
      });
    });
    
    updateLegend();
  });

function subscribeToStream(stream) {
  socket.emit("subscribe", { stream });
  socket.on(stream, data => {
    if (Array.isArray(data)) {
      streamData[stream] = data;
    } else {
      if (!streamData[stream]) streamData[stream] = [];
      streamData[stream].push(data);
    }
    updateChart();
  });
}

document.getElementById("window-select").addEventListener("change", (e) => {
  displayWindow = parseInt(e.target.value, 10);
  updateChart();
});

function updateChart() {
  // Flatten all data to get global x domain
  const now = Date.now() / 1000; // current time in seconds
  
  // Filter data to only include points within the selected window
  const filteredData = {};
  for (const [stream, data] of Object.entries(streamData)) {
    filteredData[stream] = data.filter(d => d.date >= now - displayWindow);
  }
  
  const allFiltered = Object.values(filteredData).flat();
    // Always update the legend regardless of data availability
  updateLegend();
  // Only proceed with chart update if we have data
  if (allFiltered.length === 0) return;
  
  const minDate = d3.min(allFiltered, d => d.date);
  const maxDate = d3.max(allFiltered, d => d.date);
  const xBuffer = Math.max(1, (maxDate - minDate) * 0.05);
  
  x.domain([
    new Date((minDate - xBuffer) * 1000),
    new Date((maxDate + xBuffer) * 1000)
  ]);
  xAxisGroup.call(d3.axisBottom(x).tickFormat(d3.utcFormat("%H:%M:%S")));
  yAxisGroup.call(d3.axisLeft(y));

  // Data join for multiple lines
  const streams = Array.from(subscribedStreams);
  const lines = svg.selectAll(".data-line")
    .data(streams, d => d);

  // ENTER + UPDATE
  lines.enter()
    .append("path")
    .attr("class", "data-line")
    .attr("fill", "none")
    .attr("stroke-width", 2)
    .attr("stroke", d => streamColors[d] || "#000")
    .merge(lines)
    .attr("d", d => d3.line()
      .x(pt => x(new Date(pt.date * 1000)))
      .y(pt => y(pt.value))
      (filteredData[d] || [])
    );

  // EXIT
  lines.exit().remove();
  
  updateLegend();
}
function updateLegend() {
  // Clear existing legend
  legend.selectAll("*").remove();
  
  // Add a legend item for each active stream
  const streams = Array.from(subscribedStreams);
  streams.forEach((stream, i) => {
    const legendItem = legend.append("g")
      .attr("transform", `translate(0, ${i * 20})`);
      
    legendItem.append("rect")
      .attr("width", 10)
      .attr("height", 10)
      .attr("fill", streamColors[stream]);
      
    legendItem.append("text")
      .attr("x", 15)
      .attr("y", 9)
      .text(streamNames[stream]);
  });
}

// Add some CSS styles
const style = document.createElement('style');
style.textContent = `
  .controls {
    display: flex;
    flex-direction: column;
    margin: 10px 0;
  }
  .checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 10px;
  }
  .checkbox-item {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .colour-swatch {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 2px;
  }
`;
document.head.appendChild(style);
</script>
